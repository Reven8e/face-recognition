elf.rcdataState
        return True

    def rcdataEndTagNameState(self):
        appropriate = self.currentToken and self.currentToken["name"].lower() == self.temporaryBuffer.lower()
        data = self.stream.char()
        if data in spaceCharacters and appropriate:
            self.currentToken = {"type": tokenTypes["EndTag"],
                                 "name": self.temporaryBuffer,
                                 "data": [], "selfClosing": False}
            self.state = self.beforeAttributeNameState
        elif data == "/" and appropriate:
            self.currentToken = {"type": tokenTypes["EndTag"],
                                 "name": self.temporaryBuffer,
                                 "data": [], "selfClosing": False}
            self.state = self.selfClosingStartTagState
        elif data == ">" and appropriate:
            self.currentToken = {"type": tokenTypes["EndTag"],
                                 "name": self.temporaryBuffer,
                                 "data": [], "selfClosing": False}
            self.emitCurrentToken()
            self.state = self.dataState
        elif data in asciiLetters:
            self.temporaryBuffer += data
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"],
                                    "data": "</" + self.temporaryBuffer})
            self.stream.unget(data)
            self.state = self.rcdataState
        return True

    def rawtextLessThanSignState(self):
        data = self.stream.char()
        if data == "/":
            self.temporaryBuffer = ""
            self.state = self.rawtextEndTagOpenState
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "<"})
            self.stream.unget(data)
            self.state = self.rawtextState
        return True

    def rawtextEndTagOpenState(self):
        data = self.stream.char()
        if data in asciiLetters:
            self.temporaryBuffer += data
            self.state = self.rawtextEndTagNameState
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "</"})
            self.stream.unget(data)
            self.state = self.rawtextState
        return True

    def rawtextEndTagNameState(self):
        appropriate = self.currentToken and self.currentToken["name"].lower() == self.temporaryBuffer.lower()
        data = self.stream.char()
        if data in spaceCharacters and appropriate:
            self.currentToken = {"type": tokenTypes["EndTag"],
                                 "name": self.temporaryBuffer,
                                 "data": [], "selfClosing": False}
            self.state = self.beforeAttributeNameState
        elif data == "/" and appropriate:
            self.currentToken = {"type": tokenTypes["EndTag"],
                                 "name": self.temporaryBuffer,
                                 "data": [], "selfClosing": False}
            self.state = self.selfClosingStartTagState
        elif data == ">" and appropriate:
            self.currentToken = {"type": tokenTypes["EndTag"],
                                 "name": self.temporaryBuffer,
                                 "data": [], "selfClosing": False}
            self.emitCurrentToken()
            self.state = self.dataState
        elif data in asciiLetters:
            self.temporaryBuffer += data
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"],
                                    "data": "</" + self.temporaryBuffer})
            self.stream.unget(data)
            self.state = self.rawtextState
        return True

    def scriptDataLessThanSignState(self):
        data = self.stream.char()
        if data == "/":
            self.temporaryBuffer = ""
            self.state = self.scriptDataEndTagOpenState
        elif data == "!":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "<!"})
            self.state = self.scriptDataEscapeStartState
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "<"})
            self.stream.unget(data)
            self.state = self.scriptDataState
        return True

    def scriptDataEndTagOpenState(self):
        data = self.stream.char()
        if data in asciiLetters:
            self.temporaryBuffer += data
            self.state = self.scriptDataEndTagNameState
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "</"})
            self.stream.unget(data)
            self.state = self.scriptDataState
        return True

    def scriptDataEndTagNameState(self):
        appropriate = self.currentToken and self.currentToken["name"].lower() == self.temporaryBuffer.lower()
        data = self.stream.char()
        if data in spaceCharacters and appropriate:
            self.currentToken = {"type": tokenTypes["EndTag"],
                                 "name": self.temporaryBuffer,
                                 "data": [], "selfClosing": False}
            self.state = self.beforeAttributeNameState
        elif data == "/" and appropriate:
            self.currentToken = {"type": tokenTypes["EndTag"],
                                 "name": self.temporaryBuffer,
                                 "data": [], "selfClosing": False}
            self.state = self.selfClosingStartTagState
        elif data == ">" and appropriate:
            self.currentToken = {"type": tokenTypes["EndTag"],
                                 "name": self.temporaryBuffer,
                                 "data": [], "selfClosing": False}
            self.emitCurrentToken()
            self.state = self.dataState
        elif data in asciiLetters:
            self.temporaryBuffer += data
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"],
                                    "data": "</" + self.temporaryBuffer})
            self.stream.unget(data)
            self.state = self.scriptDataState
        return True

    def scriptDataEscapeStartState(self):
        data = self.stream.char()
        if data == "-":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "-"})
            self.state = self.scriptDataEscapeStartDashState
        else:
            self.stream.unget(data)
            self.state = self.scriptDataState
        return True

    def scriptDataEscapeStartDashState(self):
        data = self.stream.char()
        if data == "-":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "-"})
            self.state = self.scriptDataEscapedDashDashState
        else:
            self.stream.unget(data)
            self.state = self.scriptDataState
        return True

    def scriptDataEscapedState(self):
        data = self.stream.char()
        if data == "-":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "-"})
            self.state = self.scriptDataEscapedDashState
        elif data == "<":
            self.state = self.scriptDataEscapedLessThanSignState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.tokenQueue.append({"type": tokenTypes["Characters"],
                                    "data": "\uFFFD"})
        elif data == EOF:
            self.state = self.dataState
        else:
            chars = self.stream.charsUntil(("<", "-", "\u0000"))
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data":
                                    data + chars})
        return True

    def scriptDataEscapedDashState(self):
        data = self.stream.char()
        if data == "-":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "-"})
            self.state = self.scriptDataEscapedDashDashState
        elif data == "<":
            self.state = self.scriptDataEscapedLessThanSignState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.tokenQueue.append({"type": tokenTypes["Characters"],
                                    "data": "\uFFFD"})
            self.state = self.scriptDataEscapedState
        elif data == EOF:
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": data})
            self.state = self.scriptDataEscapedState
        return True

    def scriptDataEscapedDashDashState(self):
        data = self.stream.char()
        if data == "-":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "-"})
        elif data == "<":
            self.state = self.scriptDataEscapedLessThanSignState
        elif data == ">":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": ">"})
            self.state = self.scriptDataState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.tokenQueue.append({"type": tokenTypes["Characters"],
                                    "data": "\uFFFD"})
            self.state = self.scriptDataEscapedState
        elif data == EOF:
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": data})
            self.state = self.scriptDataEscapedState
        return True

    def scriptDataEscapedLessThanSignState(self):
        data = self.stream.char()
        if data == "/":
            self.temporaryBuffer = ""
            self.state = self.scriptDataEscapedEndTagOpenState
        elif data in asciiLetters:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "<" + data})
            self.temporaryBuffer = data
            self.state = self.scriptDataDoubleEscapeStartState
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "<"})
            self.stream.unget(data)
            self.state = self.scriptDataEscapedState
        return True

    def scriptDataEscapedEndTagOpenState(self):
        data = self.stream.char()
        if data in asciiLetters:
            self.temporaryBuffer = data
            self.state = self.scriptDataEscapedEndTagNameState
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "</"})
            self.stream.unget(data)
            self.state = self.scriptDataEscapedState
        return True

    def scriptDataEscapedEndTagNameState(self):
        appropriate = self.currentToken and self.currentToken["name"].lower() == self.temporaryBuffer.lower()
        data = self.stream.char()
        if data in spaceCharacters and appropriate:
            self.currentToken = {"type": tokenTypes["EndTag"],
                                 "name": self.temporaryBuffer,
                                 "data": [], "selfClosing": False}
            self.state = self.beforeAttributeNameState
        elif data == "/" and appropriate:
            self.currentToken = {"type": tokenTypes["EndTag"],
                                 "name": self.temporaryBuffer,
                                 "data": [], "selfClosing": False}
            self.state = self.selfClosingStartTagState
        elif data == ">" and appropriate:
            self.currentToken = {"type": tokenTypes["EndTag"],
                                 "name": self.temporaryBuffer,
                                 "data": [], "selfClosing": False}
            self.emitCurrentToken()
            self.state = self.dataState
        elif data in asciiLetters:
            self.temporaryBuffer += data
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"],
                                    "data": "</" + self.temporaryBuffer})
            self.stream.unget(data)
            self.state = self.scriptDataEscapedState
        return True

    def scriptDataDoubleEscapeStartState(self):
        data = self.stream.char()
        if data in (spaceCharacters | frozenset(("/", ">"))):
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": data})
            if self.temporaryBuffer.lower() == "script":
                self.state = self.scriptDataDoubleEscapedState
            else:
                self.state = self.scriptDataEscapedState
        elif data in asciiLetters:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": data})
            self.temporaryBuffer += data
        else:
            self.stream.unget(data)
            self.state = self.scriptDataEscapedState
        return True

    def scriptDataDoubleEscapedState(self):
        data = self.stream.char()
        if data == "-":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "-"})
            self.state = self.scriptDataDoubleEscapedDashState
        elif data == "<":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "<"})
            self.state = self.scriptDataDoubleEscapedLessThanSignState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.tokenQueue.append({"type": tokenTypes["Characters"],
                                    "data": "\uFFFD"})
        elif data == EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-script-in-script"})
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": data})
        return True

    def scriptDataDoubleEscapedDashState(self):
        data = self.stream.char()
        if data == "-":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "-"})
            self.state = self.scriptDataDoubleEscapedDashDashState
        elif data == "<":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "<"})
            self.state = self.scriptDataDoubleEscapedLessThanSignState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.tokenQueue.append({"type": tokenTypes["Characters"],
                                    "data": "\uFFFD"})
            self.state = self.scriptDataDoubleEscapedState
        elif data == EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-script-in-script"})
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": data})
            self.state = self.scriptDataDoubleEscapedState
        return True

    def scriptDataDoubleEscapedDashDashState(self):
        data = self.stream.char()
        if data == "-":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "-"})
        elif data == "<":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "<"})
            self.state = self.scriptDataDoubleEscapedLessThanSignState
        elif data == ">":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": ">"})
            self.state = self.scriptDataState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.tokenQueue.append({"type": tokenTypes["Characters"],
                                    "data": "\uFFFD"})
            self.state = self.scriptDataDoubleEscapedState
        elif data == EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-script-in-script"})
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": data})
            self.state = self.scriptDataDoubleEscapedState
        return True

    def scriptDataDoubleEscapedLessThanSignState(self):
        data = self.stream.char()
        if data == "/":
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": "/"})
            self.temporaryBuffer = ""
            self.state = self.scriptDataDoubleEscapeEndState
        else:
            self.stream.unget(data)
            self.state = self.scriptDataDoubleEscapedState
        return True

    def scriptDataDoubleEscapeEndState(self):
        data = self.stream.char()
        if data in (spaceCharacters | frozenset(("/", ">"))):
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": data})
            if self.temporaryBuffer.lower() == "script":
                self.state = self.scriptDataEscapedState
            else:
                self.state = self.scriptDataDoubleEscapedState
        elif data in asciiLetters:
            self.tokenQueue.append({"type": tokenTypes["Characters"], "data": data})
            self.temporaryBuffer += data
        else:
            self.stream.unget(data)
            self.state = self.scriptDataDoubleEscapedState
        return True

    def beforeAttributeNameState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            self.stream.charsUntil(spaceCharacters, True)
        elif data in asciiLetters:
            self.currentToken["data"].append([data, ""])
            self.state = self.attributeNameState
        elif data == ">":
            self.emitCurrentToken()
        elif data == "/":
            self.state = self.selfClosingStartTagState
        elif data in ("'", '"', "=", "<"):
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "invalid-character-in-attribute-name"})
            self.currentToken["data"].append([data, ""])
            self.state = self.attributeNameState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["data"].append(["\uFFFD", ""])
            self.state = self.attributeNameState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "expected-attribute-name-but-got-eof"})
            self.state = self.dataState
        else:
            self.currentToken["data"].append([data, ""])
            self.state = self.attributeNameState
        return True

    def attributeNameState(self):
        data = self.stream.char()
        leavingThisState = True
        emitToken = False
        if data == "=":
            self.state = self.beforeAttributeValueState
        elif data in asciiLetters:
            self.currentToken["data"][-1][0] += data +\
                self.stream.charsUntil(asciiLetters, True)
            leavingThisState = False
        elif data == ">":
            # XXX If we emit here the attributes are converted to a dict
            # without being checked and when the code below runs we error
            # because data is a dict not a list
            emitToken = True
        elif data in spaceCharacters:
            self.state = self.afterAttributeNameState
        elif data == "/":
            self.state = self.selfClosingStartTagState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["data"][-1][0] += "\uFFFD"
            leavingThisState = False
        elif data in ("'", '"', "<"):
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data":
                                    "invalid-character-in-attribute-name"})
            self.currentToken["data"][-1][0] += data
            leavingThisState = False
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "eof-in-attribute-name"})
            self.state = self.dataState
        else:
            self.currentToken["data"][-1][0] += data
            leavingThisState = False

        if leavingThisState:
            # Attributes are not dropped at this stage. That happens when the
            # start tag token is emitted so values can still be safely appended
            # to attributes, but we do want to report the parse error in time.
            self.currentToken["data"][-1][0] = (
                self.currentToken["data"][-1][0].translate(asciiUpper2Lower))
            for name, _ in self.currentToken["data"][:-1]:
                if self.currentToken["data"][-1][0] == name:
                    self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                            "duplicate-attribute"})
                    break
            # XXX Fix for above XXX
            if emitToken:
                self.emitCurrentToken()
        return True

    def afterAttributeNameState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            self.stream.charsUntil(spaceCharacters, True)
        elif data == "=":
            self.state = self.beforeAttributeValueState
        elif data == ">":
            self.emitCurrentToken()
        elif data in asciiLetters:
            self.currentToken["data"].append([data, ""])
            self.state = self.attributeNameState
        elif data == "/":
            self.state = self.selfClosingStartTagState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["data"].append(["\uFFFD", ""])
            self.state = self.attributeNameState
        elif data in ("'", '"', "<"):
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "invalid-character-after-attribute-name"})
            self.currentToken["data"].append([data, ""])
            self.state = self.attributeNameState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "expected-end-of-tag-but-got-eof"})
            self.state = self.dataState
        else:
            self.currentToken["data"].append([data, ""])
            self.state = self.attributeNameState
        return True

    def beforeAttributeValueState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            self.stream.charsUntil(spaceCharacters, True)
        elif data == "\"":
            self.state = self.attributeValueDoubleQuotedState
        elif data == "&":
            self.state = self.attributeValueUnQuotedState
            self.stream.unget(data)
        elif data == "'":
            self.state = self.attributeValueSingleQuotedState
        elif data == ">":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "expected-attribute-value-but-got-right-bracket"})
            self.emitCurrentToken()
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["data"][-1][1] += "\uFFFD"
            self.state = self.attributeValueUnQuotedState
        elif data in ("=", "<", "`"):
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "equals-in-unquoted-attribute-value"})
            self.currentToken["data"][-1][1] += data
            self.state = self.attributeValueUnQuotedState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "expected-attribute-value-but-got-eof"})
            self.state = self.dataState
        else:
            self.currentToken["data"][-1][1] += data
            self.state = self.attributeValueUnQuotedState
        return True

    def attributeValueDoubleQuotedState(self):
        data = self.stream.char()
        if data == "\"":
            self.state = self.afterAttributeValueState
        elif data == "&":
            self.processEntityInAttribute('"')
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["data"][-1][1] += "\uFFFD"
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-attribute-value-double-quote"})
            self.state = self.dataState
        else:
            self.currentToken["data"][-1][1] += data +\
                self.stream.charsUntil(("\"", "&", "\u0000"))
        return True

    def attributeValueSingleQuotedState(self):
        data = self.stream.char()
        if data == "'":
            self.state = self.afterAttributeValueState
        elif data == "&":
            self.processEntityInAttribute("'")
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["data"][-1][1] += "\uFFFD"
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-attribute-value-single-quote"})
            self.state = self.dataState
        else:
            self.currentToken["data"][-1][1] += data +\
                self.stream.charsUntil(("'", "&", "\u0000"))
        return True

    def attributeValueUnQuotedState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            self.state = self.beforeAttributeNameState
        elif data == "&":
            self.processEntityInAttribute(">")
        elif data == ">":
            self.emitCurrentToken()
        elif data in ('"', "'", "=", "<", "`"):
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-character-in-unquoted-attribute-value"})
            self.currentToken["data"][-1][1] += data
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["data"][-1][1] += "\uFFFD"
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-attribute-value-no-quotes"})
            self.state = self.dataState
        else:
            self.currentToken["data"][-1][1] += data + self.stream.charsUntil(
                frozenset(("&", ">", '"', "'", "=", "<", "`", "\u0000")) | spaceCharacters)
        return True

    def afterAttributeValueState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            self.state = self.beforeAttributeNameState
        elif data == ">":
            self.emitCurrentToken()
        elif data == "/":
            self.state = self.selfClosingStartTagState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-EOF-after-attribute-value"})
            self.stream.unget(data)
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-character-after-attribute-value"})
            self.stream.unget(data)
            self.state = self.beforeAttributeNameState
        return True

    def selfClosingStartTagState(self):
        data = self.stream.char()
        if data == ">":
            self.currentToken["selfClosing"] = True
            self.emitCurrentToken()
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data":
                                    "unexpected-EOF-after-solidus-in-tag"})
            self.stream.unget(data)
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-character-after-solidus-in-tag"})
            self.stream.unget(data)
            self.state = self.beforeAttributeNameState
        return True

    def bogusCommentState(self):
        # Make a new comment token and give it as value all the characters
        # until the first > or EOF (charsUntil checks for EOF automatically)
        # and emit it.
        data = self.stream.charsUntil(">")
        data = data.replace("\u0000", "\uFFFD")
        self.tokenQueue.append(
            {"type": tokenTypes["Comment"], "data": data})

        # Eat the character directly after the bogus comment which is either a
        # ">" or an EOF.
        self.stream.char()
        self.state = self.dataState
        return True

    def markupDeclarationOpenState(self):
        charStack = [self.stream.char()]
        if charStack[-1] == "-":
            charStack.append(self.stream.char())
            if charStack[-1] == "-":
                self.currentToken = {"type": tokenTypes["Comment"], "data": ""}
                self.state = self.commentStartState
                return True
        elif charStack[-1] in ('d', 'D'):
            matched = True
            for expected in (('o', 'O'), ('c', 'C'), ('t', 'T'),
                             ('y', 'Y'), ('p', 'P'), ('e', 'E')):
                charStack.append(self.stream.char())
                if charStack[-1] not in expected:
                    matched = False
                    break
            if matched:
                self.currentToken = {"type": tokenTypes["Doctype"],
                                     "name": "",
                                     "publicId": None, "systemId": None,
                                     "correct": True}
                self.state = self.doctypeState
                return True
        elif (charStack[-1] == "[" and
              self.parser is not None and
              self.parser.tree.openElements and
              self.parser.tree.openElements[-1].namespace != self.parser.tree.defaultNamespace):
            matched = True
            for expected in ["C", "D", "A", "T", "A", "["]:
                charStack.append(self.stream.char())
                if charStack[-1] != expected:
                    matched = False
                    break
            if matched:
                self.state = self.cdataSectionState
                return True

        self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                "expected-dashes-or-doctype"})

        while charStack:
            self.stream.unget(charStack.pop())
        self.state = self.bogusCommentState
        return True

    def commentStartState(self):
        data = self.stream.char()
        if data == "-":
            self.state = self.commentStartDashState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["data"] += "\uFFFD"
        elif data == ">":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "incorrect-comment"})
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-comment"})
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.currentToken["data"] += data
            self.state = self.commentState
        return True

    def commentStartDashState(self):
        data = self.stream.char()
        if data == "-":
            self.state = self.commentEndState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["data"] += "-\uFFFD"
        elif data == ">":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "incorrect-comment"})
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-comment"})
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.currentToken["data"] += "-" + data
            self.state = self.commentState
        return True

    def commentState(self):
        data = self.stream.char()
        if data == "-":
            self.state = self.commentEndDashState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["data"] += "\uFFFD"
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "eof-in-comment"})
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.currentToken["data"] += data + \
                self.stream.charsUntil(("-", "\u0000"))
        return True

    def commentEndDashState(self):
        data = self.stream.char()
        if data == "-":
            self.state = self.commentEndState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["data"] += "-\uFFFD"
            self.state = self.commentState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-comment-end-dash"})
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.currentToken["data"] += "-" + data
            self.state = self.commentState
        return True

    def commentEndState(self):
        data = self.stream.char()
        if data == ">":
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["data"] += "--\uFFFD"
            self.state = self.commentState
        elif data == "!":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-bang-after-double-dash-in-comment"})
            self.state = self.commentEndBangState
        elif data == "-":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-dash-after-double-dash-in-comment"})
            self.currentToken["data"] += data
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-comment-double-dash"})
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            # XXX
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-char-in-comment"})
            self.currentToken["data"] += "--" + data
            self.state = self.commentState
        return True

    def commentEndBangState(self):
        data = self.stream.char()
        if data == ">":
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data == "-":
            self.currentToken["data"] += "--!"
            self.state = self.commentEndDashState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["data"] += "--!\uFFFD"
            self.state = self.commentState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-comment-end-bang-state"})
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.currentToken["data"] += "--!" + data
            self.state = self.commentState
        return True

    def doctypeState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            self.state = self.beforeDoctypeNameState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "expected-doctype-name-but-got-eof"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "need-space-after-doctype"})
            self.stream.unget(data)
            self.state = self.beforeDoctypeNameState
        return True

    def beforeDoctypeNameState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            pass
        elif data == ">":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "expected-doctype-name-but-got-right-bracket"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["name"] = "\uFFFD"
            self.state = self.doctypeNameState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "expected-doctype-name-but-got-eof"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.currentToken["name"] = data
            self.state = self.doctypeNameState
        return True

    def doctypeNameState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            self.currentToken["name"] = self.currentToken["name"].translate(asciiUpper2Lower)
            self.state = self.afterDoctypeNameState
        elif data == ">":
            self.currentToken["name"] = self.currentToken["name"].translate(asciiUpper2Lower)
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["name"] += "\uFFFD"
            self.state = self.doctypeNameState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-doctype-name"})
            self.currentToken["correct"] = False
            self.currentToken["name"] = self.currentToken["name"].translate(asciiUpper2Lower)
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.currentToken["name"] += data
        return True

    def afterDoctypeNameState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            pass
        elif data == ">":
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data is EOF:
            self.currentToken["correct"] = False
            self.stream.unget(data)
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-doctype"})
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            if data in ("p", "P"):
                matched = True
                for expected in (("u", "U"), ("b", "B"), ("l", "L"),
                                 ("i", "I"), ("c", "C")):
                    data = self.stream.char()
                    if data not in expected:
                        matched = False
                        break
                if matched:
                    self.state = self.afterDoctypePublicKeywordState
                    return True
            elif data in ("s", "S"):
                matched = True
                for expected in (("y", "Y"), ("s", "S"), ("t", "T"),
                                 ("e", "E"), ("m", "M")):
                    data = self.stream.char()
                    if data not in expected:
                        matched = False
                        break
                if matched:
                    self.state = self.afterDoctypeSystemKeywordState
                    return True

            # All the characters read before the current 'data' will be
            # [a-zA-Z], so they're garbage in the bogus doctype and can be
            # discarded; only the latest character might be '>' or EOF
            # and needs to be ungetted
            self.stream.unget(data)
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "expected-space-or-right-bracket-in-doctype", "datavars":
                                    {"data": data}})
            self.currentToken["correct"] = False
            self.state = self.bogusDoctypeState

        return True

    def afterDoctypePublicKeywordState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            self.state = self.beforeDoctypePublicIdentifierState
        elif data in ("'", '"'):
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-char-in-doctype"})
            self.stream.unget(data)
            self.state = self.beforeDoctypePublicIdentifierState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.stream.unget(data)
            self.state = self.beforeDoctypePublicIdentifierState
        return True

    def beforeDoctypePublicIdentifierState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            pass
        elif data == "\"":
            self.currentToken["publicId"] = ""
            self.state = self.doctypePublicIdentifierDoubleQuotedState
        elif data == "'":
            self.currentToken["publicId"] = ""
            self.state = self.doctypePublicIdentifierSingleQuotedState
        elif data == ">":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-end-of-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-char-in-doctype"})
            self.currentToken["correct"] = False
            self.state = self.bogusDoctypeState
        return True

    def doctypePublicIdentifierDoubleQuotedState(self):
        data = self.stream.char()
        if data == "\"":
            self.state = self.afterDoctypePublicIdentifierState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["publicId"] += "\uFFFD"
        elif data == ">":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-end-of-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.currentToken["publicId"] += data
        return True

    def doctypePublicIdentifierSingleQuotedState(self):
        data = self.stream.char()
        if data == "'":
            self.state = self.afterDoctypePublicIdentifierState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["publicId"] += "\uFFFD"
        elif data == ">":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-end-of-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.currentToken["publicId"] += data
        return True

    def afterDoctypePublicIdentifierState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            self.state = self.betweenDoctypePublicAndSystemIdentifiersState
        elif data == ">":
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data == '"':
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-char-in-doctype"})
            self.currentToken["systemId"] = ""
            self.state = self.doctypeSystemIdentifierDoubleQuotedState
        elif data == "'":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-char-in-doctype"})
            self.currentToken["systemId"] = ""
            self.state = self.doctypeSystemIdentifierSingleQuotedState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-char-in-doctype"})
            self.currentToken["correct"] = False
            self.state = self.bogusDoctypeState
        return True

    def betweenDoctypePublicAndSystemIdentifiersState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            pass
        elif data == ">":
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data == '"':
            self.currentToken["systemId"] = ""
            self.state = self.doctypeSystemIdentifierDoubleQuotedState
        elif data == "'":
            self.currentToken["systemId"] = ""
            self.state = self.doctypeSystemIdentifierSingleQuotedState
        elif data == EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-char-in-doctype"})
            self.currentToken["correct"] = False
            self.state = self.bogusDoctypeState
        return True

    def afterDoctypeSystemKeywordState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            self.state = self.beforeDoctypeSystemIdentifierState
        elif data in ("'", '"'):
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-char-in-doctype"})
            self.stream.unget(data)
            self.state = self.beforeDoctypeSystemIdentifierState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.stream.unget(data)
            self.state = self.beforeDoctypeSystemIdentifierState
        return True

    def beforeDoctypeSystemIdentifierState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            pass
        elif data == "\"":
            self.currentToken["systemId"] = ""
            self.state = self.doctypeSystemIdentifierDoubleQuotedState
        elif data == "'":
            self.currentToken["systemId"] = ""
            self.state = self.doctypeSystemIdentifierSingleQuotedState
        elif data == ">":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-char-in-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-char-in-doctype"})
            self.currentToken["correct"] = False
            self.state = self.bogusDoctypeState
        return True

    def doctypeSystemIdentifierDoubleQuotedState(self):
        data = self.stream.char()
        if data == "\"":
            self.state = self.afterDoctypeSystemIdentifierState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["systemId"] += "\uFFFD"
        elif data == ">":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-end-of-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.currentToken["systemId"] += data
        return True

    def doctypeSystemIdentifierSingleQuotedState(self):
        data = self.stream.char()
        if data == "'":
            self.state = self.afterDoctypeSystemIdentifierState
        elif data == "\u0000":
            self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                    "data": "invalid-codepoint"})
            self.currentToken["systemId"] += "\uFFFD"
        elif data == ">":
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-end-of-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.currentToken["systemId"] += data
        return True

    def afterDoctypeSystemIdentifierState(self):
        data = self.stream.char()
        if data in spaceCharacters:
            pass
        elif data == ">":
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data is EOF:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "eof-in-doctype"})
            self.currentToken["correct"] = False
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            self.tokenQueue.append({"type": tokenTypes["ParseError"], "data":
                                    "unexpected-char-in-doctype"})
            self.state = self.bogusDoctypeState
        return True

    def bogusDoctypeState(self):
        data = self.stream.char()
        if data == ">":
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        elif data is EOF:
            # XXX EMIT
            self.stream.unget(data)
            self.tokenQueue.append(self.currentToken)
            self.state = self.dataState
        else:
            pass
        return True

    def cdataSectionState(self):
        data = []
        while True:
            data.append(self.stream.charsUntil("]"))
            data.append(self.stream.charsUntil(">"))
            char = self.stream.char()
            if char == EOF:
                break
            else:
                assert char == ">"
                if data[-1][-2:] == "]]":
                    data[-1] = data[-1][:-2]
                    break
                else:
                    data.append(char)

        data = "".join(data)  # pylint:disable=redefined-variable-type
        # Deal with null here rather than in the parser
        nullCount = data.count("\u0000")
        if nullCount > 0:
            for _ in range(nullCount):
                self.tokenQueue.append({"type": tokenTypes["ParseError"],
                                        "data": "invalid-codepoint"})
            data = data.replace("\u0000", "\uFFFD")
        if data:
            self.tokenQueue.append({"type": tokenTypes["Characters"],
                                    "data": data})
        self.state = self.dataState
        return True
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                U
    )L_F                   @   s-  d dl mZmZmZ d dlZdZddddddd	d
dddddddddddddddddddddd d!d"d#d$d%d&d'd(d)d*d+d,d-d.d/d,d,d0d1d2d3d4d5d6d7d8d9d:d;d<d=d>d?d@dAdBdCdDdEdFdGdHdIdJdKdLdMdNdOdPdQdRdSdTdUdVdWdXdYdZd[d\d]d^d_d`dadbdcdddedfdgdhdidjdkdldmdndodpdqdrdsdtdudvdwdxdydzd{d|d}d~dddddZdddddddZeed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfgZ	eed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfgZ
eed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfed dfgNZeed dfed dfed dfed dfgZeed dfed dfed dfed dfed dfgZddddddddddddddddd ddddddddd	d
dddddddddddddddddddddd d!d"d#d$d%d&d'd(d)d*d+d,d-d.>Zd/d0iZd1d2ed1 fd1d3ed1 fd1d4ed1 fd1d5ed1 fd1d6ed1 fd1ded1 fd1d7ed1 fd8ded8 fd8d9ed8 fd8d:ed8 fdd;ed; fd;d1ed; fd<Zd=d> e D Zed?d@dAdBdCgZedddddgZeejZeejZeejZeejZeejZdDd> ejD ZdEZedddFdddddddddddGdHgZ eddgZ!edddddddgZ"edIdJgedKgedLgedMdNgedMdNgedOdPgedQgedRdSgedTdSdUdVgedWgedXgedSdYgedSdYdZgedSdYgedSd[gedSdYd\d[dUdLgedSdYd[dRgedSdYged]gd^Z#d_Z$ed`dadbdcddgZ%dededfdfdgdgdhdididjdkdldldmdndodpdqdrdsdsdtdudvdvdwdwdxdydzd{d|d}d~dddd}dddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd ddddddddd	d
ddddddddddddddddddddddddddddd d!d"d#d$d%d&d'd(d)d*d*d+d,d-d.d/d0d1d2d3d4d5d6d7d8d9d:d;d;d<d=d>d?d@dAdBdCdDdEdFdGdHdIdJdKdLdMdNdOdPdQdRdSdTdUdVdWdXdYdZd[ddd\d]d^d_d`dadbdcdddedfdgdhddddidjdkd?dldmdndodpdqdrdsdtdudrdvdwdxdydzd{d|d|d|d|d	dnd@d}d~dddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd dddddddddd	d
dddddddddddddddEdddddddddd d!d"d#d$d%d&d&d'd(d)d*d+dd,d-d.d/d-d0d0d1d2d3d?d4d5d6d7d8d9d:d;d<d=d>d?d@dAdBdCdDdEdEdFdGdHdIdJdJdKdLdMdNdNdOdPdQdRdSdTdUdVdWddXdYdZd[d\d]ddd^d_d`dadbdcdddededfdgdhdidjdkdldldmdndodpdqdrdsdtdudvdwdxdydzd{d|d}d~ddddddddddddddddd|ddddddddddddddddddrdddddddddfdfddddddddddddddddddddddsdddd@dddddd@dddddd@dddddddddddddddddRddddd|d|ddd}ddddd!ddTdddddddddkdwddddddddddddddddd\d\ddddddddddddddddddddddd dddddddddd	d
ddddddddddddddddddddddddddddddd d!d"d#d$d%d&dd'd(d)d)d*d+d,d-ddd.d/d/dd0d1d2d2d3d4d5d6d7d8d9dd:d;d<d=d7d>d?d@dAdAdBdududCdDdEddEdd?dFddGddddHdIdJdKdLdMdNdOdPdQdRdSdTdUdVdWdXdYdZd[d\d]d^d_dSdTd`dadbdbdUd^d`daddcddddedfdgddhdPdiddjdkdddldmdndndodpdqdrdKddddsdsddtdudvdvdvdwdwdxdydzd{d|ddd}d~dddzddldKdddddddddddddddddmd}dddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddtddddddddddddddddddd	ddddddddddddddddddddddddddddddddddddddqddddNdd dddddddddd	d
dddddddddhddd"ddddddddddddddddddd'ddd d!dd"d#d$dd d%dd%d&d'd(d)d*d+d'd,d,d-dd.d/d0d1dd#d2d3d4d4d5d6d7d8d9d:d;d<d=d>d?d@dAdBdCdDdEdFddddGdHd]dIdJdKdLd?dMdDdNdDdOdPdPdEdFdQdRddSdTdUdVdWdXdYdZd[d\d]d^d_d`dadbdcdHd]dddedddfdgdhdidEdVddZdjdNdGdd dkd\did]d`d`dldmdndodpdqdOdrd\dId^dadsdMdtd^duddZdvdwdxdndjdydydzd{d|d|d}d~d~ddd}ddddIdfdgddhdSdddddddPddddddGddddddddldaddd^dddd;d;dddrdkddddddUdddddddddddddddQd]ddddddddddmddddddd~ddddtdddtddddddddddddddddddddddddddddddddddddddddddd_d_ddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd^d^dd:d d d;d<dddd=dddddddd	d
d
ddddd8ddddddddddddddd9ddddddddddddd d d!d"d"dd#d$d$d%dd&d&dd'd(dd)d*d+d,d\d-d.d/d0drd1d2dd3dd4dd5d6d	d7dd8d9ddd:d;dd<d=d>d>dd?d@dddd@dddAdBdCddDddBdAdCddEdFdGddddHdIdJdKdLddMdNdOddPdQdddd
ddRdidSdTdUddVddWdXddYdYddZdd[d\d]ddd^d_d`dadbdcdddddedfdgdhdidjdkddedldmdndddodddddpdddqddrdddsdtdudd`dddddvdadwdxddddydzdzd{d|d}dd~dddddddvddddfdddwdddddddddd(dddd*d)ddddddd+dddddddkdkdddddxdxdddddddmddddddd=dd>d>ddddddddEdxdddmddddddddddddddd#ddd dd d!d"d!d"dddddddxdd%dddd0ddddd'dddddddd'ddddddd(dd*d)dddd+d,dddddddd.dddd/ddddddddd.d/dddddddddjdjddddddddddBddd9d9dddd@d=d<d@d=dddddd
dddddddddddd1ddddUdddddddddddddddd@ddddddddd d ddYdd[dddddXdddddd	d
ddddddZdXddUdd`ddddddddddddddddddddddd>dd0d3ddZdudddddddSddddd d!d"dndnd#dSddd$ddd%ddddd&d'd(dd)d*d+d,d*dpdpd-d!ddTdd.ddgd/ddfdd0dd1ddddhd2ddddkdwd3d3d4d5d6d7d7d8d9d:d;d<d=d=d>d?d@dAddBdCdDdEdFdGdHdIdJZ&dKdCddLdddddfdd6d,ddddMddNdOddddddddd1ddddPd?ddQ"Z'd dRdSdTdUdVdWdXdYZ(ee(dZ e(d[ e(d\ gZ)d]d> e D Z*d^e*d< G d_d` d`e+Z,G dadb dbe-Z.dS (c      )absolute_importdivisionunicode_literalsNz5Null character in input stream, replaced with U+FFFD.zInvalid codepoint in stream.z&Solidus (/) incorrectly placed in tag.z.Incorrect CR newline entity, replaced with LF.z9Entity used with illegal number (windows-1252 reference).zPNumeric entity couldn't be converted to character (codepoint U+%(charAsInt)08x).zBNumeric entity represents an illegal codepoint: U+%(charAsInt)08x.z#Numeric entity didn't end with ';'.z1Numeric entity expected. Got end of file instead.z'Numeric entity expected but none found.z!Named entity didn't end with ';'.z Named entity expected. Got none.z'End tag contains unexpected attributes.z.End tag contains unexpected self-closing flag.z#Expected tag name. Got '>' instead.zSExpected tag name. Got '?' instead. (HTML doesn't support processing instructions.)z-Expected tag name. Got something else insteadz6Expected closing tag. Got '>' instead. Ignoring '</>'.z-Expected closing tag. Unexpected end of file.z<Expected closing tag. Unexpected character '%(data)s' found.z'Unexpected end of file in the tag name.z8Unexpected end of file. Expected attribute name instead.z)Unexpected end of file in attribute name.z#Invalid character in attribute namez#Dropped duplicate attribute on tag.z1Unexpected end of file. Expected = or end of tag.z1Unexpected end of file. Expected attribute value.z*Expected attribute value. Got '>' instead.z"Unexpected = in unquoted attributez*Unexpected character in unquoted attributez*Unexpected character after attribute name.z+Unexpected character after attribute value.z.Unexpected end of file in attribute value (").z.Unexpected end of file in attribute value (').z*Unexpected end of file in attribute value.z)Unexpected end of file in tag. Expected >z/Unexpected character after / in tag. Expected >z&Expected '--' or 'DOCTYPE'. Not found.z Unexpected ! after -- in commentz$Unexpected space after -- in commentzIncorrect comment.z"Unexpected end of file in comment.z%Unexpected end of file in comment (-)z+Unexpected '-' after '--' found in comment.z'Unexpected end of file in comment (--).z&Unexpected character in comment found.z(No space after literal string 'DOCTYPE'.z.Unexpected > character. Expected DOCTYPE name.z.Unexpected end of file. Expected DOCTYPE name.z'Unexpected end of file in DOCTYPE name.z"Unexpected end of file in DOCTYPE.z%Expected space or '>'. Got '%(data)s'zUnexpected end of DOCTYPE.z Unexpected character in DOCTYPE.zXXX innerHTML EOFzUnexpected DOCTYPE. Ignored.z%html needs to be the first start tag.z)Unexpected End of file. Expected DOCTYPE.zErroneous DOCTYPE.z2Unexpected non-space characters. Expected DOCTYPE.z2Unexpected start tag (%(name)s). Expected DOCTYPE.z0Unexpected end tag (%(name)s). Expected DOCTYPE.z?Unexpected end tag (%(name)s) after the (implied) root element.z4Unexpected end of file. Expected end tag (%(name)s).z4Unexpected start tag head in existing head. Ignored.z'Unexpected end tag (%(name)s). Ignored.z;Unexpected start tag (%(name)s) that can be in head. Moved.z Unexpected start tag (%(name)s).zMissing end tag (%(name)s).zMissing end tags (%(name)s).zCUnexpected start tag (%(startName)s) implies end tag (%(endName)s).z@Unexpected start tag (%(originalName)s). Treated as %(newName)s.z,Unexpected start tag %(name)s. Don't use it!z'Unexpected start tag %(name)s. Ignored.zEUnexpected end tag (%(gotName)s). Missing end tag (%(expectedName)s).z:End tag (%(name)s) seen too early. Expected other end tag.zFUnexpected end tag (%(gotName)s). Expected end tag (%(expectedName)s).z+End tag (%(name)s) seen too early. Ignored.zQEnd tag (%(name)s) violates step 1, paragraph 1 of the adoption agency algorithm.zQEnd tag (%(name)s) violates step 1, paragraph 2 of the adoption agency algorithm.zQEnd tag (%(name)s) violates step 1, paragraph 3 of the adoption agency algorithm.zQEnd tag (%(name)s) violates step 4, paragraph 4 of the adoption agency algorithm.z>Unexpected end tag (%(originalName)s). Treated as %(newName)s.z'This element (%(name)s) has no end tag.z9Unexpected implied end tag (%(name)s) in the table phase.z>Unexpected implied end tag (%(name)s) in the table body phase.zDUnexpected non-space characters in table context caused voodoo mode.z3Unexpected input with type hidden in table context.z!Unexpected form in table context.zDUnexpected start tag (%(name)s) in table context caused voodoo mode.zBUnexpected end tag (%(name)s) in table context caused voodoo mode.zCUnexpected table cell start tag (%(name)s) in the table body phase.zFGot table cell end tag (%(name)s) while required end tags are missing.z?Unexpected end tag (%(name)s) in the table body phase. Ignored.z=Unexpected implied end tag (%(name)s) in the table row phase.z>Unexpected end tag (%(name)s) in the table row phase. Ignored.zJUnexpected select start tag in the select phase treated as select end tag.z/Unexpected input start tag in the select phase.zBUnexpected start tag token (%(name)s in the select phase. Ignored.z;Unexpected end tag (%(name)s) in the select phase. Ignored.zKUnexpected table element start tag (%(name)s) in the select in table phase.zIUnexpected table element end tag (%(name)s) in the select in table phase.z8Unexpected non-space characters in the after body phase.z>Unexpected start tag token (%(name)s) in the after body phase.z<Unexpected end tag token (%(name)s) in the after body phase.z@Unexpected characters in the frameset phase. Characters ignored.zEUnexpected start tag token (%(name)s) in the frameset phase. Ignored.zFUnexpected end tag token (frameset) in the frameset phase (innerHTML).zCUnexpected end tag token (%(name)s) in the frameset phase. Ignored.zEUnexpected non-space characters in the after frameset phase. Ignored.zEUnexpected start tag (%(name)s) in the after frameset phase. Ignored.zCUnexpected end tag (%(name)s) in the after frameset phase. Ignored.z(Unexpected end tag after body(innerHtml)z6Unexpected non-space characters. Expected end of file.z6Unexpected start tag (%(name)s). Expected end of file.z4Unexpected end tag (%(name)s). Expected end of file.z/Unexpected end of file. Expected table content.z0Unexpected end of file. Expected select content.z2Unexpected end of file. Expected frameset content.z0Unexpected end of file. Expected script content.z0Unexpected end of file. Expected foreign contentz0Trailing solidus not allowed on element %(name)sz2Element %(name)s not allowed in a non-html contextz*Unexpected end tag (%(name)s) before html.z9Element %(name)s not allowed in a inhead-noscript contextz8Unexpected end of file. Expected inhead-noscript contentz@Unexpected non-space character. Expected inhead-noscript contentz0Undefined error (this sucks and should be fixed))znull-characterzinvalid-codepointzincorrectly-placed-soliduszincorrect-cr-newline-entityzillegal-windows-1252-entityzcant-convert-numeric-entityz$illegal-codepoint-for-numeric-entityz numeric-entity-without-semicolonz#expected-numeric-entity-but-got-eofzexpected-numeric-entityznamed-entity-without-semicolonzexpected-named-entityzattributes-in-end-tagzself-closing-flag-on-end-tagz'expected-tag-name-but-got-right-bracketz'expected-tag-name-but-got-question-markzexpected-tag-namez*expected-closing-tag-but-got-right-bracketz expected-closing-tag-but-got-eofz!expected-closing-tag-but-got-charzeof-in-tag-namez#expected-attribute-name-but-got-eofzeof-in-attribute-namez#invalid-character-in-attribute-namezduplicate-attributez$expected-end-of-tag-name-but-got-eofz$expected-attribute-value-but-got-eofz.expected-attribute-value-but-got-right-bracketz"equals-in-unquoted-attribute-valuez0unexpected-character-in-unquoted-attribute-valuez&invalid-character-after-attribute-namez*unexpected-character-after-attribute-valuez#eof-in-attribute-value-double-quotez#eof-in-attribute-value-single-quotez eof-in-attribute-value-no-quotesz#unexpected-EOF-after-solidus-in-tagz)unexpected-character-after-solidus-in-tagzexpected-dashes-or-doctypez,unexpected-bang-after-double-dash-in-commentz-unexpected-space-after-double-dash-in-commentzincorrect-commentzeof-in-commentzeof-in-comment-end-dashz,unexpected-dash-after-double-dash-in-commentzeof-in-comment-double-dashzeof-in-comment-end-space-statezeof-in-comment-end-bang-statezunexpected-char-in-commentzneed-space-after-doctypez+expected-doctype-name-but-got-right-bracketz!expected-doctype-name-but-got-eofzeof-in-doctype-namezeof-in-doctypez*expected-space-or-right-bracket-in-doctypezunexpected-end-of-doctypezunexpected-char-in-doctypezeof-in-innerhtmlzunexpected-doctypeznon-html-rootzexpected-doctype-but-got-eofzunknown-doctypezexpected-doctype-but-got-charsz"expected-doctype-but-got-start-tagz expected-doctype-but-got-end-tagzend-tag-after-implied-rootz&expected-named-closing-tag-but-got-eofz!two-heads-are-not-better-than-onezunexpected-end-tagz#unexpected-start-tag-out-of-my-headzunexpected-start-tagzmissing-end-tagzmissing-end-tagsz$unexpected-start-tag-implies-end-tagzunexpected-start-tag-treated-aszdeprecated-tagzunexpected-start-tag-ignoredz$expected-one-end-tag-but-got-anotherzend-tag-too-earlyzend-tag-too-early-namedzend-tag-too-early-ignoredzadoption-agency-1.1zadoption-agency-1.2zadoption-agency-1.3zadoption-agency-4.4zunexpected-end-tag-treated-asz
no-end-tagz#unexpected-implied-end-tag-in-tablez(unexpected-implied-end-tag-in-table-bodyz$unexpected-char-implies-table-voodooz unexpected-hidden-input-in-tablezunexpected-form-in-tablez)unexpected-start-tag-implies-table-voodooz'unexpected-end-tag-implies-table-voodoozunexpected-cell-in-table-bodyzunexpected-cell-end-tagz unexpected-end-tag-in-table-bodyz'unexpected-implied-end-tag-in-table-rowzunexpected-end-tag-in-table-rowzunexpected-select-in-selectzunexpected-input-in-selectzunexpected-start-tag-in-selectzunexpected-end-tag-in-selectz5unexpected-table-element-start-tag-in-select-in-tablez3unexpected-table-element-end-tag-in-select-in-tablezunexpected-char-after-bodyzunexpected-start-tag-after-bodyzunexpected-end-tag-after-bodyzunexpected-char-in-framesetz unexpected-start-tag-in-framesetz)unexpected-frameset-in-frameset-innerhtmlzunexpected-end-tag-in-framesetzunexpected-char-after-framesetz#unexpected-start-tag-after-framesetz!unexpected-end-tag-after-framesetz'unexpected-end-tag-after-body-innerhtmlzexpected-eof-but-got-charzexpected-eof-but-got-start-tagzexpected-eof-but-got-end-tagzeof-in-tablezeof-in-selectzeof-in-framesetzeof-in-script-in-scriptzeof-in-foreign-landsz&non-void-element-with-trailing-solidusz*unexpected-html-element-in-foreign-contentzunexpected-end-tag-before-htmlzunexpected-inhead-noscript-tagzeof-in-head-noscriptzchar-in-head-noscriptzXXX-undefined-errorzhttp://www.w3.org/1999/xhtmlz"http://www.w3.org/1998/Math/MathMLzhttp://www.w3.org/2000/svgzhttp://www.w3.org/1999/xlinkz$http://www.w3.org/XML/1998/namespacezhttp://www.w3.org/2000/xmlns/)htmlmathmlsvgxlinkxmlxmlnsr   appletcaptionmarqueeobjecttabletdthr   mimomnmsmtextzannotation-xmlr   foreignObjectdesctitleabbigcodeemfontinobrssmallstrikestrongttuaddressareaarticleasidebasebasefontbgsound
blockquotebodybrbuttoncentercolcolgroupcommanddddetailsdirdivdldtembedfieldsetfigurefooterformframeframeseth1h2h3h4h5h6headheaderhriframeimageimginputisindexlilinklistingmenumetanavnoembednoframesnoscriptolpparam	plaintextprescriptsectionselectstyletbodytextareatfoottheadtrulwbrxmpattributeNameattributeTypebaseFrequencybaseProfilecalcModeclipPathUnitscontentScriptTypecontentStyleTypediffuseConstantedgeModeexternalResourcesRequired	filterResfilterUnitsglyphRefgradientTransformgradientUnitskernelMatrixkernelUnitLength	keyPoints
keySplineskeyTimeslengthAdjustlimitingConeAnglemarkerHeightmarkerUnitsmarkerWidthmaskContentUnits	maskUnits
numOctaves
pathLengthpatternContentUnitspatternTransformpatternUnits	pointsAtX	pointsAtY	pointsAtZpreserveAlphapreserveAspectRatioprimitiveUnitsrefXrefYrepeatCount	repeatDurrequiredExtensionsrequiredFeaturesspecularConstantspecularExponentspreadMethodstartOffsetstdDeviationstitchTilessurfaceScalesystemLanguagetableValuestargetXtargetY
textLengthviewBox
viewTargetxChannelSelectoryChannelSelector
zoomAndPan)>attributenameattributetypebasefrequencybaseprofilecalcmodeclippathunitscontentscripttypecontentstyletypediffuseconstantedgemodeexternalresourcesrequired	filterresfilterunitsglyphrefgradienttransformgradientunitskernelmatrixkernelunitlength	keypoints
keysplineskeytimeslengthadjustlimitingconeanglemarkerheightmarkerunitsmarkerwidthmaskcontentunits	maskunits
numoctaves
pathlengthpatterncontentunitspatterntransformpatternunits	pointsatx	pointsaty	pointsatzpreservealphapreserveaspectratioprimitiveunitsrefxrefyrepeatcount	repeatdurrequiredextensionsrequiredfeaturesspecularconstantspecularexponentspreadmethodstartoffsetstddeviationstitchtilessurfacescalesystemlanguagetablevaluestargetxtargety
textlengthviewbox
viewtargetxchannelselectorychannelselector
zoomandpandefinitionurldefinitionURLr   actuatearcrolehrefroleshowtyper	   langspacer
   )zxlink:actuatezxlink:arcrolez
xlink:hrefz
xlink:rolez
xlink:showzxlink:titlez
xlink:typezxml:basezxml:langz	xml:spacer
   zxmlns:xlinkc                 C   s    i | ]\}\}}}||f|qS  r   ).0qnameprefixlocalnsr   r   B/tmp/pip-unpacked-wheel-wok8ou_f/pip/_vendor/html5lib/constants.py
<dictcomp>
  s      r   	
 c                 C   s   i | ]}t |t | qS r   )ordlower)r   cr   r   r   r   #  s      )rD   rE   rF   rG   rH   rI   zevent-sourcesourcetrack
irrelevant	itemscopescopedismapautoplaycontrolsdeferasyncopenmultipledisabledhiddencheckeddefaultnoshade
autosubmitreadonlyselected	autofocusrequiredseamless) rc   rO   audiovideor`   r8   datagridr6   rL   rU   r>   optionoptgroupr2   rP   rb   outputrM   ) i     i   i  i   i&   i    i!   i  i0   i`  i9   iR  r   i}  r   r   i   i   i   i   i"   i   i   i  i"!  ia  i:   iS  r   i~  ix  lt;gt;amp;apos;quot;   &   u      u   u      u   u   u   u   u   u      u   u         u   u   u   u   u   u   u   u   u   u   u   u      u   u   u   u   u      u   u   u         u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u      u   u   `u   u   u   u      u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u         u      u   u   u      u   u   u   u   u   u   u   u   u   u   u   u   u      u   u   u   u   u   u   u   u   u   u   >u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   ^u   u   u   u   u   u   u   u   u   u         u   u   u      u   u   u   u   u   u   u   u   u   u   u   u   u      u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   <u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u      u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u      u   u         u   u   u      u   u   u   u   u   u   u   u         u      u   u   u   u   u   u   u   u   u      u   u   u   u   u   u   u   u   u   u   u   "u   u   u   u      u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u      u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u      u   u   u   u      u   u   u      u   _u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u      u   u   u   u   u   u   u   u   |u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u      u   u   u   u   u   u   u   u   u   u   u   u   u   u   u      u   u   u   u      u      u      u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   '   u   *      u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   =u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u      u   u   \u   u   u   u   u   u   u   u   u   u   u   u   u   u   u      u   u   u   u   u      u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   :,@u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u      u   u   u   u   u   u   u   u   u   u   u      u   u   u   u   u   u   u      u   u   u   u   $u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u      u   u   u      u   u   u   u   u   u      u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   =u   u   u   u   u   u   u         u   !u   u   u   u   u   u   u   fju   u   u   u   u   u   u   u      u      u   u   u   u   u      u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u         u   u      u      u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u      u   u   u   u   u   u   u      u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u      u   u   u   u   u   u   u   u   u   u   u   u   {[u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   (u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u      u   u   u   u   u   u   u   u      u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u      u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u      u   #u   u   u   u   u   u   u   u   >u   u   u   u   <u   u   u   u   u   u   u         u   u   u   u   u   u   u   u      u   u   u   u   u   u   u   u   u   u   u   u   u   u   u         u   u   u   u      u      u      u      u   u   u   %.u   u   u   u   u   u   u   u   u   +u   u   u   u   u   u   u   u      u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   ?u   u   u   u   u   u   u      u   u   u   u   u   u   u   u   u   u   u   }]u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   )u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u      ;u   u   u   u   u   u      u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   /u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u            u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u      u   u   u   u   u   u   u   u   u         u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u      u   u      u   u   u   u      u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u      u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u   u      u   u   u      u   u   u   u   u      u   u   u   u   u   u   u   u   u   u   u   u   (  AEligzAElig;AMPzAMP;AacutezAacute;zAbreve;AcirczAcirc;zAcy;zAfr;AgravezAgrave;zAlpha;zAmacr;zAnd;zAogon;zAopf;zApplyFunction;AringzAring;zAscr;zAssign;AtildezAtilde;AumlzAuml;z
Backslash;zBarv;zBarwed;zBcy;zBecause;zBernoullis;zBeta;zBfr;zBopf;zBreve;zBscr;zBumpeq;zCHcy;COPYzCOPY;zCacute;zCap;zCapitalDifferentialD;zCayleys;zCcaron;CcedilzCcedil;zCcirc;zCconint;zCdot;zCedilla;z
CenterDot;zCfr;zChi;z
CircleDot;zCircleMinus;zCirclePlus;zCircleTimes;zClockwiseContourIntegral;zCloseCurlyDoubleQuote;zCloseCurlyQuote;zColon;zColone;z
Congruent;zConint;zContourIntegral;zCopf;z
Coproduct;z CounterClockwiseContourIntegral;zCross;zCscr;zCup;zCupCap;zDD;z	DDotrahd;zDJcy;zDScy;zDZcy;zDagger;zDarr;zDashv;zDcaron;zDcy;zDel;zDelta;zDfr;zDiacriticalAcute;zDiacriticalDot;zDiacriticalDoubleAcute;zDiacriticalGrave;zDiacriticalTilde;zDiamond;zDifferentialD;zDopf;zDot;zDotDot;z	DotEqual;zDoubleContourIntegral;z
DoubleDot;zDoubleDownArrow;zDoubleLeftArrow;zDoubleLeftRightArrow;zDoubleLeftTee;zDoubleLongLeftArrow;zDoubleLongLeftRightArrow;zDoubleLongRightArrow;zDoubleRightArrow;zDoubleRightTee;zDoubleUpArrow;zDoubleUpDownArrow;zDoubleVerticalBar;z
DownArrow;zDownArrowBar;zDownArrowUpArrow;z
DownBreve;zDownLeftRightVector;zDownLeftTeeVector;zDownLeftVector;zDownLeftVectorBar;zDownRightTeeVector;zDownRightVector;zDownRightVectorBar;zDownTee;zDownTeeArrow;z
Downarrow;zDscr;zDstrok;zENG;ETHzETH;EacutezEacute;zEcaron;EcirczEcirc;zEcy;zEdot;zEfr;EgravezEgrave;zElement;zEmacr;zEmptySmallSquare;zEmptyVerySmallSquare;zEogon;zEopf;zEpsilon;zEqual;zEqualTilde;zEquilibrium;zEscr;zEsim;zEta;EumlzEuml;zExists;zExponentialE;zFcy;zFfr;zFilledSmallSquare;zFilledVerySmallSquare;zFopf;zForAll;zFouriertrf;zFscr;zGJcy;GTzGT;zGamma;zGammad;zGbreve;zGcedil;zGcirc;zGcy;zGdot;zGfr;zGg;zGopf;zGreaterEqual;zGreaterEqualLess;zGreaterFullEqual;zGreaterGreater;zGreaterLess;zGreaterSlantEqual;zGreaterTilde;zGscr;zGt;zHARDcy;zHacek;zHat;zHcirc;zHfr;zHilbertSpace;zHopf;zHorizontalLine;zHscr;zHstrok;zHumpDownHump;z
HumpEqual;zIEcy;zIJlig;zIOcy;IacutezIacute;IcirczIcirc;zIcy;zIdot;zIfr;IgravezIgrave;zIm;zImacr;zImaginaryI;zImplies;zInt;z	Integral;zIntersection;zInvisibleComma;zInvisibleTimes;zIogon;zIopf;zIota;zIscr;zItilde;zIukcy;IumlzIuml;zJcirc;zJcy;zJfr;zJopf;zJscr;zJsercy;zJukcy;zKHcy;zKJcy;zKappa;zKcedil;zKcy;zKfr;zKopf;zKscr;zLJcy;LTzLT;zLacute;zLambda;zLang;zLaplacetrf;zLarr;zLcaron;zLcedil;zLcy;zLeftAngleBracket;z
LeftArrow;zLeftArrowBar;zLeftArrowRightArrow;zLeftCeiling;zLeftDoubleBracket;zLeftDownTeeVector;zLeftDownVector;zLeftDownVectorBar;z
LeftFloor;zLeftRightArrow;zLeftRightVector;zLeftTee;zLeftTeeArrow;zLeftTeeVector;zLeftTriangle;zLeftTriangleBar;zLeftTriangleEqual;zLeftUpDownVector;zLeftUpTeeVector;zLeftUpVector;zLeftUpVectorBar;zLeftVector;zLeftVectorBar;z
Leftarrow;zLeftrightarrow;zLessEqualGreater;zLessFullEqual;zLessGreater;z	LessLess;zLessSlantEqual;z
LessTilde;zLfr;zLl;zLleftarrow;zLmidot;zLongLeftArrow;zLongLeftRightArrow;zLongRightArrow;zLongleftarrow;zLongleftrightarrow;zLongrightarrow;zLopf;zLowerLeftArrow;zLowerRightArrow;zLscr;zLsh;zLstrok;zLt;zMap;zMcy;zMediumSpace;z
Mellintrf;zMfr;z
MinusPlus;zMopf;zMscr;zMu;zNJcy;zNacute;zNcaron;zNcedil;zNcy;zNegativeMediumSpace;zNegativeThickSpace;zNegativeThinSpace;zNegativeVeryThinSpace;zNestedGreaterGreater;zNestedLessLess;zNewLine;zNfr;zNoBreak;zNonBreakingSpace;zNopf;zNot;zNotCongruent;z
NotCupCap;zNotDoubleVerticalBar;zNotElement;z	NotEqual;zNotEqualTilde;z
NotExists;zNotGreater;zNotGreaterEqual;zNotGreaterFullEqual;zNotGreaterGreater;zNotGreaterLess;zNotGreaterSlantEqual;zNotGreaterTilde;zNotHumpDownHump;zNotHumpEqual;zNotLeftTriangle;zNotLeftTriangleBar;zNotLeftTriangleEqual;zNotLess;zNotLessEqual;zNotLessGreater;zNotLessLess;zNotLessSlantEqual;zNotLessTilde;zNotNestedGreaterGreater;zNotNestedLessLess;zNotPrecedes;zNotPrecedesEqual;zNotPrecedesSlantEqual;zNotReverseElement;zNotRightTriangle;zNotRightTriangleBar;zNotRightTriangleEqual;zNotSquareSubset;zNotSquareSubsetEqual;zNotSquareSuperset;zNotSquareSupersetEqual;z
NotSubset;zNotSubsetEqual;zNotSucceeds;zNotSucceedsEqual;zNotSucceedsSlantEqual;zNotSucceedsTilde;zNotSuperset;zNotSupersetEqual;z	NotTilde;zNotTildeEqual;zNotTildeFullEqual;zNotTildeTilde;zNotVerticalBar;zNscr;NtildezNtilde;zNu;zOElig;OacutezOacute;OcirczOcirc;zOcy;zOdblac;zOfr;OgravezOgrave;zOmacr;zOmega;zOmicron;zOopf;zOpenCurlyDoubleQuote;zOpenCurlyQuote;zOr;zOscr;OslashzOslash;OtildezOtilde;zOtimes;OumlzOuml;zOverBar;z
OverBrace;zOverBracket;zOverParenthesis;z	PartialD;zPcy;zPfr;zPhi;zPi;z
PlusMinus;zPoincareplane;zPopf;zPr;z	Precedes;zPrecedesEqual;zPrecedesSlantEqual;zPrecedesTilde;zPrime;zProduct;zProportion;zProportional;zPscr;zPsi;QUOTzQUOT;zQfr;zQopf;zQscr;zRBarr;REGzREG;zRacute;zRang;zRarr;zRarrtl;zRcaron;zRcedil;zRcy;zRe;zReverseElement;zReverseEquilibrium;zReverseUpEquilibrium;zRfr;zRho;zRightAngleBracket;zRightArrow;zRightArrowBar;zRightArrowLeftArrow;zRightCeiling;zRightDoubleBracket;zRightDownTeeVector;zRightDownVector;zRightDownVectorBar;zRightFloor;z	RightTee;zRightTeeArrow;zRightTeeVector;zRightTriangle;zRightTriangleBar;zRightTriangleEqual;zRightUpDownVector;zRightUpTeeVector;zRightUpVector;zRightUpVectorBar;zRightVector;zRightVectorBar;zRightarrow;zRopf;zRoundImplies;zRrightarrow;zRscr;zRsh;zRuleDelayed;zSHCHcy;zSHcy;zSOFTcy;zSacute;zSc;zScaron;zScedil;zScirc;zScy;zSfr;zShortDownArrow;zShortLeftArrow;zShortRightArrow;zShortUpArrow;zSigma;zSmallCircle;zSopf;zSqrt;zSquare;zSquareIntersection;zSquareSubset;zSquareSubsetEqual;zSquareSuperset;zSquareSupersetEqual;zSquareUnion;zSscr;zStar;zSub;zSubset;zSubsetEqual;z	Succeeds;zSucceedsEqual;zSucceedsSlantEqual;zSucceedsTilde;z	SuchThat;zSum;zSup;z	Superset;zSupersetEqual;zSupset;THORNzTHORN;zTRADE;zTSHcy;zTScy;zTab;zTau;zTcaron;zTcedil;zTcy;zTfr;z
Therefore;zTheta;zThickSpace;z
ThinSpace;zTilde;zTildeEqual;zTildeFullEqual;zTildeTilde;zTopf;z
TripleDot;zTscr;zTstrok;UacutezUacute;zUarr;z	Uarrocir;zUbrcy;zUbreve;UcirczUcirc;zUcy;zUdblac;zUfr;UgravezUgrave;zUmacr;z	UnderBar;zUnderBrace;zUnderBracket;zUnderParenthesis;zUnion;z
UnionPlus;zUogon;zUopf;zUpArrow;zUpArrowBar;zUpArrowDownArrow;zUpDownArrow;zUpEquilibrium;zUpTee;zUpTeeArrow;zUparrow;zUpdownarrow;zUpperLeftArrow;zUpperRightArrow;zUpsi;zUpsilon;zUring;zUscr;zUtilde;UumlzUuml;zVDash;zVbar;zVcy;zVdash;zVdashl;zVee;zVerbar;zVert;zVerticalBar;zVerticalLine;zVerticalSeparator;zVerticalTilde;zVeryThinSpace;zVfr;zVopf;zVscr;zVvdash;zWcirc;zWedge;zWfr;zWopf;zWscr;zXfr;zXi;zXopf;zXscr;zYAcy;zYIcy;zYUcy;YacutezYacute;zYcirc;zYcy;zYfr;zYopf;zYscr;zYuml;zZHcy;zZacute;zZcaron;zZcy;zZdot;zZeroWidthSpace;zZeta;zZfr;zZopf;zZscr;aacutezaacute;zabreve;zac;zacE;zacd;acirczacirc;acutezacute;zacy;aeligzaelig;zaf;zafr;agravezagrave;zalefsym;zaleph;zalpha;zamacr;zamalg;ampr#  zand;zandand;zandd;z	andslope;zandv;zang;zange;zangle;zangmsd;z	angmsdaa;z	angmsdab;z	angmsdac;z	angmsdad;z	angmsdae;z	angmsdaf;z	angmsdag;z	angmsdah;zangrt;zangrtvb;z	angrtvbd;zangsph;zangst;zangzarr;zaogon;zaopf;zap;zapE;zapacir;zape;zapid;r$  zapprox;z	approxeq;aringzaring;zascr;zast;zasymp;zasympeq;atildezatilde;aumlzauml;z	awconint;zawint;zbNot;z	backcong;zbackepsilon;z
backprime;zbacksim;z
backsimeq;zbarvee;zbarwed;z	barwedge;zbbrk;z	bbrktbrk;zbcong;zbcy;zbdquo;zbecaus;zbecause;zbemptyv;zbepsi;zbernou;zbeta;zbeth;zbetween;zbfr;zbigcap;zbigcirc;zbigcup;zbigodot;z	bigoplus;z
bigotimes;z	bigsqcup;zbigstar;zbigtriangledown;zbigtriangleup;z	biguplus;zbigvee;z	bigwedge;zbkarow;zblacklozenge;zblacksquare;zblacktriangle;zblacktriangledown;zblacktriangleleft;zblacktriangleright;zblank;zblk12;zblk14;zblk34;zblock;zbne;zbnequiv;zbnot;zbopf;zbot;zbottom;zbowtie;zboxDL;zboxDR;zboxDl;zboxDr;zboxH;zboxHD;zboxHU;zboxHd;zboxHu;zboxUL;zboxUR;zboxUl;zboxUr;zboxV;zboxVH;zboxVL;zboxVR;zboxVh;zboxVl;zboxVr;zboxbox;zboxdL;zboxdR;zboxdl;zboxdr;zboxh;zboxhD;zboxhU;zboxhd;zboxhu;z	boxminus;zboxplus;z	boxtimes;zboxuL;zboxuR;zboxul;zboxur;zboxv;zboxvH;zboxvL;zboxvR;zboxvh;zboxvl;zboxvr;zbprime;zbreve;brvbarzbrvbar;zbscr;zbsemi;zbsim;zbsime;zbsol;zbsolb;z	bsolhsub;zbull;zbullet;zbump;zbumpE;zbumpe;zbumpeq;zcacute;zcap;zcapand;z	capbrcup;zcapcap;zcapcup;zcapdot;zcaps;zcaret;zcaron;zccaps;zccaron;ccedilzccedil;zccirc;zccups;zccupssm;zcdot;cedilzcedil;zcemptyv;centzcent;z
centerdot;zcfr;zchcy;zcheck;z
checkmark;zchi;zcir;zcirE;zcirc;zcirceq;zcirclearrowleft;zcirclearrowright;z	circledR;z	circledS;zcircledast;zcircledcirc;zcircleddash;zcire;z	cirfnint;zcirmid;zcirscir;zclubs;z	clubsuit;zcolon;zcolone;zcoloneq;zcomma;zcommat;zcomp;zcompfn;zcomplement;z
complexes;zcong;zcongdot;zconint;zcopf;zcoprod;copyzcopy;zcopysr;zcrarr;zcross;zcscr;zcsub;zcsube;zcsup;zcsupe;zctdot;zcudarrl;zcudarrr;zcuepr;zcuesc;zcularr;zcularrp;zcup;z	cupbrcap;zcupcap;zcupcup;zcupdot;zcupor;zcups;zcurarr;zcurarrm;zcurlyeqprec;zcurlyeqsucc;z	curlyvee;zcurlywedge;currenzcurren;zcurvearrowleft;zcurvearrowright;zcuvee;zcuwed;z	cwconint;zcwint;zcylcty;zdArr;zdHar;zdagger;zdaleth;zdarr;zdash;zdashv;zdbkarow;zdblac;zdcaron;zdcy;zdd;zddagger;zddarr;zddotseq;degzdeg;zdelta;zdemptyv;zdfisht;zdfr;zdharl;zdharr;zdiam;zdiamond;zdiamondsuit;zdiams;zdie;zdigamma;zdisin;zdiv;dividezdivide;zdivideontimes;zdivonx;zdjcy;zdlcorn;zdlcrop;zdollar;zdopf;zdot;zdoteq;z	doteqdot;z	dotminus;zdotplus;z
dotsquare;zdoublebarwedge;z
downarrow;zdowndownarrows;zdownharpoonleft;zdownharpoonright;z	drbkarow;zdrcorn;zdrcrop;zdscr;zdscy;zdsol;zdstrok;zdtdot;zdtri;zdtrif;zduarr;zduhar;zdwangle;zdzcy;z	dzigrarr;zeDDot;zeDot;eacutezeacute;zeaster;zecaron;zecir;ecirczecirc;zecolon;zecy;zedot;zee;zefDot;zefr;zeg;egravezegrave;zegs;zegsdot;zel;z	elinters;zell;zels;zelsdot;zemacr;zempty;z	emptyset;zemptyv;zemsp13;zemsp14;zemsp;zeng;zensp;zeogon;zeopf;zepar;zeparsl;zeplus;zepsi;zepsilon;zepsiv;zeqcirc;zeqcolon;zeqsim;zeqslantgtr;zeqslantless;zequals;zequest;zequiv;zequivDD;z	eqvparsl;zerDot;zerarr;zescr;zesdot;zesim;zeta;ethzeth;eumlzeuml;zeuro;zexcl;zexist;zexpectation;zexponentiale;zfallingdotseq;zfcy;zfemale;zffilig;zfflig;zffllig;zffr;zfilig;zfjlig;zflat;zfllig;zfltns;zfnof;zfopf;zforall;zfork;zforkv;z	fpartint;frac12zfrac12;zfrac13;frac14zfrac14;zfrac15;zfrac16;zfrac18;zfrac23;zfrac25;frac34zfrac34;zfrac35;zfrac38;zfrac45;zfrac56;zfrac58;zfrac78;zfrasl;zfrown;zfscr;zgE;zgEl;zgacute;zgamma;zgammad;zgap;zgbreve;zgcirc;zgcy;zgdot;zge;zgel;zgeq;zgeqq;z	geqslant;zges;zgescc;zgesdot;zgesdoto;z	gesdotol;zgesl;zgesles;zgfr;zgg;zggg;zgimel;zgjcy;zgl;zglE;zgla;zglj;zgnE;zgnap;z	gnapprox;zgne;zgneq;zgneqq;zgnsim;zgopf;zgrave;zgscr;zgsim;zgsime;zgsiml;gtr"  zgtcc;zgtcir;zgtdot;zgtlPar;zgtquest;z
gtrapprox;zgtrarr;zgtrdot;z
gtreqless;zgtreqqless;zgtrless;zgtrsim;z
gvertneqq;zgvnE;zhArr;zhairsp;zhalf;zhamilt;zhardcy;zharr;zharrcir;zharrw;zhbar;zhcirc;zhearts;z
heartsuit;zhellip;zhercon;zhfr;z	hksearow;z	hkswarow;zhoarr;zhomtht;zhookleftarrow;zhookrightarrow;zhopf;zhorbar;zhscr;zhslash;zhstrok;zhybull;zhyphen;iacuteziacute;zic;icirczicirc;zicy;ziecy;iexclziexcl;ziff;zifr;igravezigrave;zii;ziiiint;ziiint;ziinfin;ziiota;zijlig;zimacr;zimage;z	imagline;z	imagpart;zimath;zimof;zimped;zin;zincare;zinfin;z	infintie;zinodot;zint;zintcal;z	integers;z	intercal;z	intlarhk;zintprod;ziocy;ziogon;ziopf;ziota;ziprod;iquestziquest;ziscr;zisin;zisinE;zisindot;zisins;zisinsv;zisinv;zit;zitilde;ziukcy;iumlziuml;zjcirc;zjcy;zjfr;zjmath;zjopf;zjscr;zjsercy;zjukcy;zkappa;zkappav;zkcedil;zkcy;zkfr;zkgreen;zkhcy;zkjcy;zkopf;zkscr;zlAarr;zlArr;zlAtail;zlBarr;zlE;zlEg;zlHar;zlacute;z	laemptyv;zlagran;zlambda;zlang;zlangd;zlangle;zlap;laquozlaquo;zlarr;zlarrb;zlarrbfs;zlarrfs;zlarrhk;zlarrlp;zlarrpl;zlarrsim;zlarrtl;zlat;zlatail;zlate;zlates;zlbarr;zlbbrk;zlbrace;zlbrack;zlbrke;zlbrksld;zlbrkslu;zlcaron;zlcedil;zlceil;zlcub;zlcy;zldca;zldquo;zldquor;zldrdhar;z	ldrushar;zldsh;zle;z
leftarrow;zleftarrowtail;zleftharpoondown;zleftharpoonup;zleftleftarrows;zleftrightarrow;zleftrightarrows;zleftrightharpoons;zleftrightsquigarrow;zleftthreetimes;zleg;zleq;zleqq;z	leqslant;zles;zlescc;zlesdot;zlesdoto;z	lesdotor;zlesg;zlesges;zlessapprox;zlessdot;z
lesseqgtr;zlesseqqgtr;zlessgtr;zlesssim;zlfisht;zlfloor;zlfr;zlg;zlgE;zlhard;zlharu;zlharul;zlhblk;zljcy;zll;zllarr;z	llcorner;zllhard;zlltri;zlmidot;zlmoust;zlmoustache;zlnE;zlnap;z	lnapprox;zlne;zlneq;zlneqq;zlnsim;zloang;zloarr;zlobrk;zlongleftarrow;zlongleftrightarrow;zlongmapsto;zlongrightarrow;zlooparrowleft;zlooparrowright;zlopar;zlopf;zloplus;zlotimes;zlowast;zlowbar;zloz;zlozenge;zlozf;zlpar;zlparlt;zlrarr;z	lrcorner;zlrhar;zlrhard;zlrm;zlrtri;zlsaquo;zlscr;zlsh;zlsim;zlsime;zlsimg;zlsqb;zlsquo;zlsquor;zlstrok;ltr!  zltcc;zltcir;zltdot;zlthree;zltimes;zltlarr;zltquest;zltrPar;zltri;zltrie;zltrif;z	lurdshar;zluruhar;z
lvertneqq;zlvnE;zmDDot;macrzmacr;zmale;zmalt;zmaltese;zmap;zmapsto;zmapstodown;zmapstoleft;z	mapstoup;zmarker;zmcomma;zmcy;zmdash;zmeasuredangle;zmfr;zmho;microzmicro;zmid;zmidast;zmidcir;middotzmiddot;zminus;zminusb;zminusd;zminusdu;zmlcp;zmldr;zmnplus;zmodels;zmopf;zmp;zmscr;zmstpos;zmu;z	multimap;zmumap;znGg;znGt;znGtv;znLeftarrow;znLeftrightarrow;znLl;znLt;znLtv;znRightarrow;znVDash;znVdash;znabla;znacute;znang;znap;znapE;znapid;znapos;znapprox;znatur;znatural;z	naturals;nbspznbsp;znbump;znbumpe;zncap;zncaron;zncedil;zncong;z	ncongdot;zncup;zncy;zndash;zne;zneArr;znearhk;znearr;znearrow;znedot;znequiv;znesear;znesim;znexist;znexists;znfr;zngE;znge;zngeq;zngeqq;z
ngeqslant;znges;zngsim;zngt;zngtr;znhArr;znharr;znhpar;zni;znis;znisd;zniv;znjcy;znlArr;znlE;znlarr;znldr;znle;znleftarrow;znleftrightarrow;znleq;znleqq;z
nleqslant;znles;znless;znlsim;znlt;znltri;znltrie;znmid;znopf;notznot;znotin;znotinE;z	notindot;znotinva;znotinvb;znotinvc;znotni;znotniva;znotnivb;znotnivc;znpar;z
nparallel;znparsl;znpart;znpolint;znpr;znprcue;znpre;znprec;znpreceq;znrArr;znrarr;znrarrc;znrarrw;znrightarrow;znrtri;znrtrie;znsc;znsccue;znsce;znscr;z
nshortmid;znshortparallel;znsim;znsime;znsimeq;znsmid;znspar;znsqsube;znsqsupe;znsub;znsubE;znsube;znsubset;z
nsubseteq;znsubseteqq;znsucc;znsucceq;znsup;znsupE;znsupe;znsupset;z
nsupseteq;znsupseteqq;zntgl;ntildezntilde;zntlg;zntriangleleft;zntrianglelefteq;zntriangleright;zntrianglerighteq;znu;znum;znumero;znumsp;znvDash;znvHarr;znvap;znvdash;znvge;znvgt;znvinfin;znvlArr;znvle;znvlt;znvltrie;znvrArr;znvrtrie;znvsim;znwArr;znwarhk;znwarr;znwarrow;znwnear;zoS;oacutezoacute;zoast;zocir;ocirczocirc;zocy;zodash;zodblac;zodiv;zodot;zodsold;zoelig;zofcir;zofr;zogon;ogravezograve;zogt;zohbar;zohm;zoint;zolarr;zolcir;zolcross;zoline;zolt;zomacr;zomega;zomicron;zomid;zominus;zoopf;zopar;zoperp;zoplus;zor;zorarr;zord;zorder;zorderof;ordfzordf;ordmzordm;zorigof;zoror;zorslope;zorv;zoscr;oslashzoslash;zosol;otildezotilde;zotimes;z	otimesas;oumlzouml;zovbar;zpar;parazpara;z	parallel;zparsim;zparsl;zpart;zpcy;zpercnt;zperiod;zpermil;zperp;zpertenk;zpfr;zphi;zphiv;zphmmat;zphone;zpi;z
pitchfork;zpiv;zplanck;zplanckh;zplankv;zplus;z	plusacir;zplusb;zpluscir;zplusdo;zplusdu;zpluse;plusmnzplusmn;zplussim;zplustwo;zpm;z	pointint;zpopf;poundzpound;zpr;zprE;zprap;zprcue;zpre;zprec;zprecapprox;zpreccurlyeq;zpreceq;zprecnapprox;z	precneqq;z	precnsim;zprecsim;zprime;zprimes;zprnE;zprnap;zprnsim;zprod;z	profalar;z	profline;z	profsurf;zprop;zpropto;zprsim;zprurel;zpscr;zpsi;zpuncsp;zqfr;zqint;zqopf;zqprime;zqscr;zquaternions;zquatint;zquest;zquesteq;quotr%  zrAarr;zrArr;zrAtail;zrBarr;zrHar;zrace;zracute;zradic;z	raemptyv;zrang;zrangd;zrange;zrangle;raquozraquo;zrarr;zrarrap;zrarrb;zrarrbfs;zrarrc;zrarrfs;zrarrhk;zrarrlp;zrarrpl;zrarrsim;zrarrtl;zrarrw;zratail;zratio;z
rationals;zrbarr;zrbbrk;zrbrace;zrbrack;zrbrke;zrbrksld;zrbrkslu;zrcaron;zrcedil;zrceil;zrcub;zrcy;zrdca;zrdldhar;zrdquo;zrdquor;zrdsh;zreal;zrealine;z	realpart;zreals;zrect;regzreg;zrfisht;zrfloor;zrfr;zrhard;zrharu;zrharul;zrho;zrhov;zrightarrow;zrightarrowtail;zrightharpoondown;zrightharpoonup;zrightleftarrows;zrightleftharpoons;zrightrightarrows;zrightsquigarrow;zrightthreetimes;zring;zrisingdotseq;zrlarr;zrlhar;zrlm;zrmoust;zrmoustache;zrnmid;zroang;zroarr;zrobrk;zropar;zropf;zroplus;zrotimes;zrpar;zrpargt;z	rppolint;zrrarr;zrsaquo;zrscr;zrsh;zrsqb;zrsquo;zrsquor;zrthree;zrtimes;zrtri;zrtrie;zrtrif;z	rtriltri;zruluhar;zrx;zsacute;zsbquo;zsc;zscE;zscap;zscaron;zsccue;zsce;zscedil;zscirc;zscnE;zscnap;zscnsim;z	scpolint;zscsim;zscy;zsdot;zsdotb;zsdote;zseArr;zsearhk;zsearr;zsearrow;sectzsect;zsemi;zseswar;z	setminus;zsetmn;zsext;zsfr;zsfrown;zsharp;zshchcy;zshcy;z	shortmid;zshortparallel;shyzshy;zsigma;zsigmaf;zsigmav;zsim;zsimdot;zsime;zsimeq;zsimg;zsimgE;zsiml;zsimlE;zsimne;zsimplus;zsimrarr;zslarr;zsmallsetminus;zsmashp;z	smeparsl;zsmid;zsmile;zsmt;zsmte;zsmtes;zsoftcy;zsol;zsolb;zsolbar;zsopf;zspades;z
spadesuit;zspar;zsqcap;zsqcaps;zsqcup;zsqcups;zsqsub;zsqsube;z	sqsubset;zsqsubseteq;zsqsup;zsqsupe;z	sqsupset;zsqsupseteq;zsqu;zsquare;zsquarf;zsquf;zsrarr;zsscr;zssetmn;zssmile;zsstarf;zstar;zstarf;zstraightepsilon;zstraightphi;zstrns;zsub;zsubE;zsubdot;zsube;zsubedot;zsubmult;zsubnE;zsubne;zsubplus;zsubrarr;zsubset;z	subseteq;z
subseteqq;z
subsetneq;zsubsetneqq;zsubsim;zsubsub;zsubsup;zsucc;zsuccapprox;zsucccurlyeq;zsucceq;zsuccnapprox;z	succneqq;z	succnsim;zsuccsim;zsum;zsung;sup1zsup1;sup2zsup2;sup3zsup3;zsup;zsupE;zsupdot;zsupdsub;zsupe;zsupedot;zsuphsol;zsuphsub;zsuplarr;zsupmult;zsupnE;zsupne;zsupplus;zsupset;z	supseteq;z
supseteqq;z
supsetneq;zsupsetneqq;zsupsim;zsupsub;zsupsup;zswArr;zswarhk;zswarr;zswarrow;zswnwar;szligzszlig;ztarget;ztau;ztbrk;ztcaron;ztcedil;ztcy;ztdot;ztelrec;ztfr;zthere4;z
therefore;ztheta;z	thetasym;zthetav;zthickapprox;z	thicksim;zthinsp;zthkap;zthksim;thornzthorn;ztilde;timesztimes;ztimesb;z	timesbar;ztimesd;ztint;ztoea;ztop;ztopbot;ztopcir;ztopf;ztopfork;ztosa;ztprime;ztrade;z	triangle;ztriangledown;ztriangleleft;ztrianglelefteq;z
triangleq;ztriangleright;ztrianglerighteq;ztridot;ztrie;z	triminus;ztriplus;ztrisb;ztritime;z	trpezium;ztscr;ztscy;ztshcy;ztstrok;ztwixt;ztwoheadleftarrow;ztwoheadrightarrow;zuArr;zuHar;uacutezuacute;zuarr;zubrcy;zubreve;ucirczucirc;zucy;zudarr;zudblac;zudhar;zufisht;zufr;ugravezugrave;zuharl;zuharr;zuhblk;zulcorn;z	ulcorner;zulcrop;zultri;zumacr;umlzuml;zuogon;zuopf;zuparrow;zupdownarrow;zupharpoonleft;zupharpoonright;zuplus;zupsi;zupsih;zupsilon;zupuparrows;zurcorn;z	urcorner;zurcrop;zuring;zurtri;zuscr;zutdot;zutilde;zutri;zutrif;zuuarr;uumlzuuml;zuwangle;zvArr;zvBar;zvBarv;zvDash;zvangrt;zvarepsilon;z	varkappa;zvarnothing;zvarphi;zvarpi;z
varpropto;zvarr;zvarrho;z	varsigma;zvarsubsetneq;zvarsubsetneqq;zvarsupsetneq;zvarsupsetneqq;z	vartheta;zvartriangleleft;zvartriangleright;zvcy;zvdash;zvee;zveebar;zveeeq;zvellip;zverbar;zvert;zvfr;zvltri;zvnsub;zvnsup;zvopf;zvprop;zvrtri;zvscr;zvsubnE;zvsubn